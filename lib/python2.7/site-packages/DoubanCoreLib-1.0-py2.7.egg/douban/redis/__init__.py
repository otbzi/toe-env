import time
import collections
import warnings

import redis
from redis.exceptions import ConnectionError
from douban.utils.config import read_config

SOCKET_TIMEOUT = 1  # 1s
SILENT_TIME = 10   # 10s

class ConnectionDelayedException(ConnectionError):
    pass

class DoubanRedis(redis.Redis):
    def __init__(self, *args, **kwargs):
        self._state = (args, kwargs)
        self._silent_time = kwargs.pop('silent_time', SILENT_TIME)
        self._host = kwargs.get('host', 'localhost')
        self._port = kwargs.get('port', 6379)
        self._db = kwargs.get('db', 0)
        self._last_timeout = 0  # timestamp of last socket timeout
        redis.Redis.__init__(self, *args, **kwargs)

    def __getstate__(self):
        return self._state

    def __setstate__(self, state):
        args, kwargs = state
        self.__init__(*args, **kwargs)

    def __eq__(self, other):
        return (isinstance(other, self.__class__)
            and self._state == other._state)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        name = 'douban.redis.DoubanRedis'
        return '<%s object id:%s host:%s port:%s db:%s>' % \
                (name, id(self), self._host, self._port, self._db)
    __repr__ = __str__

    def execute_command(self, *args, **options):
        "Execute a command and return a parsed response"

        secs_since_last_timeout = time.time() - self._last_timeout
        if secs_since_last_timeout < self._silent_time:
            msg = ('Timeout occurred %d seconds before, '
                   'will reconnect in %d seconds')
            msg = msg % (round(secs_since_last_timeout),
                         round(self._silent_time - secs_since_last_timeout))
            raise ConnectionDelayedException(msg)

        pool = self.connection_pool
        command_name = args[0]
        connection = pool.get_connection(command_name, **options)
        try:
            connection.send_command(*args)
            return self.parse_response(connection, command_name, **options)
        except ConnectionError, ce:
            if 'timed out' in ce.message:
                self._last_timeout = time.time()
                raise
            else:
                connection.disconnect()
                connection.send_command(*args)
                return self.parse_response(connection, command_name, **options)
        finally:
            pool.release(connection)

class RedisStore(object):
    def __init__(self, redis_config=None):
        self.apps = {}
        self.parse_config(redis_config)

    def parse_config(self, redis_config):
        for farm, config in redis_config.items():
            for db, app in config['dbs'].items():
                if app in self.apps:
                    raise Exception('Duplicated app name: "%s"' % app)
                socket_timeout = config.get('socket_timeout', SOCKET_TIMEOUT)
                rds = DoubanRedis(host=config['host'],
                                  port=config['port'],
                                  db=db,
                                  password=config.get('password', None),
                                  socket_timeout=socket_timeout)
                self.apps[app] = rds

    def get_redis(self, app):
        try:
            return self.apps[app]
        except:
            if '*' in self.apps:
                return self.apps['*']
            else:
                raise Exception('Application "%s" is unknown to RedisStore.' % app)

_clients = {}
def redis_from_config(config, use_cache=True, application='DEFAULT'):
    warnings.warn("redis_from_config is deprecated interface, please use "
                  "redis_store_from_config && rdstore.get_redis instead",
                  stacklevel=2)

    cachable = use_cache and isinstance(config, collections.Hashable)
    client = _clients.get(config) if cachable else None

    if client is None:
        if isinstance(config, basestring):
            _config = read_config(config, 'redis')
        else:
            _config = config
        host = _config.get('host', 'localhost')
        port = _config.get('port', 6379)
        dbs = _config.get('dbs', {})
        db = dbs.get(application, 0)
        password = _config.get('password', None)
        socket_timeout = _config.get('socket_timeout', SOCKET_TIMEOUT)

        client = DoubanRedis(host=host,
                             port=port,
                             db=db,
                             password=password,
                             socket_timeout=socket_timeout)

        if cachable:
            _clients[config] = client

    return client

_stores = {}
def redis_store_from_config(config, use_cache=True):
    cachable = use_cache and isinstance(config, collections.Hashable)
    store = _stores.get(config) if cachable else None

    if store is None:
        if isinstance(config, basestring):
            _config = read_config(config, 'redis')
        else:
            _config = config

        store = RedisStore(_config)

        if cachable:
            _stores[config] = store

    return store
