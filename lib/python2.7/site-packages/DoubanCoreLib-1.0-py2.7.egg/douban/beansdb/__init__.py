#!/usr/bin/env python
# encoding: utf-8
"""
__init__.py

Created by geng xinyue on 2011-02-14.
Copyright (c) 2011 douban.com. All rights reserved.
"""

import cmemcached
import sys
import time
import random
from fnv1a import get_hash

def fnv1a(s):
    return get_hash(s) & 0xffffffff


from douban.utils import ThreadedObject
from douban.utils.config import read_config

class WriteFailedError(IOError):
    def __init__(self, key):
        IOError.__init__(self)
        self.key = key

    def __repr__(self):
        return 'write %r failed' % self.key

    def __str__(self):
        return repr(self)

class ReadFailedError(IOError):
    def __init__(self, key, servers='unknown'):
        IOError.__init__(self)
        self.key = key
        self.servers = servers

    def __repr__(self):
        return 'read %r failed(%r)' % (self.key, self.servers)

    def __str__(self):
        return repr(self)



def connect(server, **kwargs):
    c = cmemcached.Client([server], do_split=0, **kwargs)
    c.set_behavior(cmemcached.BEHAVIOR_CONNECT_TIMEOUT, 300) # 0.3 s
    c.set_behavior(cmemcached.BEHAVIOR_POLL_TIMEOUT, 3000) # 3 s
    c.set_behavior(cmemcached.BEHAVIOR_SERVER_FAILURE_LIMIT, 4)
    c.set_behavior(cmemcached.BEHAVIOR_RETRY_TIMEOUT, 5) # 5 s
    return c

class MCStore(object):
    def __init__(self, addr, threaded=True, **kwargs):
        self.addr = addr
        if threaded:
            self.mc = ThreadedObject(connect, addr, **kwargs)
        else:
            self.mc = connect(addr, **kwargs)

    def __repr__(self):
        return '<MCStore(addr=%s)>' % repr(self.addr)

    def __str__(self):
        return self.addr

    def set(self, key, data, rev=0):
        return bool(self.mc.set(key, data, rev))

    def set_raw(self, key, data, rev=0, flag=0):
        if rev < 0:
            raise str(rev)
        return self.mc.set_raw(key, data, rev, flag)

    def set_multi(self, values):
        return self.mc.set_multi(values)

    def get(self, key):
        try:
            r = self.mc.get(key)
            if r is None and self.mc.get_last_error() != 0:
                raise IOError(self.mc.get_last_error())
            return r
        except ValueError:
            self.mc.delete(key)

    def get_raw(self, key):
        r, flag = self.mc.get_raw(key)
        if r is None and self.mc.get_last_error() != 0:
            raise IOError(self.mc.get_last_error(), self.mc.get_last_strerror())
        return r, flag

    def get_multi(self, keys):
        r = self.mc.get_multi(keys)
        if self.mc.get_last_error() != 0:
            raise IOError(self.mc.get_last_error(), self.mc.get_last_strerror())
        return r

    def delete(self, key):
        return bool(self.mc.delete(key))

    def delete_multi(self, keys):
        return bool(self.mc.delete_multi(keys))

    def exists(self, key):
        return bool(self.mc.get('?'+key))

    def incr(self, key, value):
        return self.mc.incr(key, int(value))


class BeansdbClient(object):

    store_cls = MCStore

    def __init__(self, addrs, update_period=10, **kwargs):
        self.addrs = addrs
        self.servers = [self.store_cls(s, **kwargs) for s in addrs]
        self.update_period = update_period
        self.buckets = []
        self.last_update = 0
        self.stat = [None] * len(addrs)

    def update(self):
        def listdir(s):
            try:
                return [int(l.split(' ')[2])
                        for l in s.get('@').strip().split('\n')]
            except Exception:
                pass 
        for i, s in enumerate(self.servers):
            if not self.stat[i]:
                self.stat[i] = listdir(s)
        
        self.buckets = []
        for i in range(16):
            ss = sorted([(st[i], j) for j, st in enumerate(self.stat) if st],
                    reverse=True)[:3]
            top = ss[0][0]
            ss = [self.servers[j] for n, j in ss if n >= top * 0.9]
            random.shuffle(ss)
            self.buckets.append(ss)

    def _get_servers(self, key):
        now = time.time()
        if self.last_update + self.update_period < now:
            self.update()
            self.last_update = now

        return self.buckets[(fnv1a(key) * 16) >> 32]

    def get(self, key, default=None):
        err_cnt = 0
        ss = self._get_servers(key)
        for s in ss:
            try:
                r = s.get(key)
                if r is not None:
                    return r
            except Exception, e:
                err_cnt += 1
                
        if err_cnt >= 2:
            raise ReadFailedError(key, ss)
        return default

    def _dispatch(self, keys):
        ss = {}
        servers = {}
        for key in keys:
            for s in self._get_servers(key):
                ss.setdefault(s.addr, []).append(key)
                servers[s.addr] = s
        sc = sorted([(len(ks), addr) for addr, ks in ss.items()])
        return [(servers[addr], ss[addr]) for _, addr in sc]
    
    def get_multi(self, keys, default=None):
        rs = {}
        for s, ks in self._dispatch(keys):
            try:
                r = s.get_multi([k for k in ks if k not in rs])
                rs.update(r)
            except IOError, e:
                pass
        for k in keys:
            if k not in rs:
                rs[k] = default
        return rs

    def exists(self, key):
        pos = '@%08x' % fnv1a(key)
        for s in self._get_servers(key):
            r = s.get(pos) or ''
            for l in r.split('\n'):
                parts = l.split(' ')
                if not parts: continue
                if key == parts[0]:
                    return int(parts[-1]) > 0
        #for s in self._get_servers(key):
        #    if s.get('?'+key):
        #        return True
        return False

    def set(self, key, value):
        ss = self._get_servers(key)
        if not any([s.set(key, value) for s in ss]):
            raise WriteFailedError(key, ss) 
        return True

    def set_multi(self, values):
        for s, ks in self._dispatch(values.keys()):
            s.set_multi(dict((k, values[k]) for k in ks))
        return True

    def delete(self, key):
        return any([s.delete(key) for s in self._get_servers(key)])

    def delete_multi(self, keys):
        for s, ks in self._dispatch(keys):
            s.delete_multi(ks)
        return True

    def incr(self, key, incr=1):
        v = 0
        for s in self._get_servers(key):
            v = max(v, s.incr(key, incr))
        return v


class BeansDBProxy(object):
    store_cls = MCStore
    threaded = True

    def __init__(self, proxies, **kwargs):
        self.servers = [self.store_cls(i,threaded=self.threaded, **kwargs) for i in proxies]

    def _get_servers(self, key):
        return self.servers

    def get(self, key, default=None):
        servers = self._get_servers(key)
        for s in servers:
            try:
                r = s.get(key)
                if r is None:
                    r = default
                return r
            except IOError:
                self.servers = self.servers[1:] + self.servers[:1]

        print >>sys.stderr, 'all backends read failed', key
        raise ReadFailedError(key, servers)

    def exists(self, key):
        for s in self._get_servers(key):
            try:
                return s.exists(key)
            except IOError:
                self.servers = self.servers[1:] + self.servers[:1]
        return False

    def get_multi(self, keys, default=None):
        for s in self._get_servers(''):
            try:
                rs = s.get_multi(keys)
                for k in keys:
                    if k not in rs:
                        rs[k] = default
                return rs
            except IOError, e: 
                self.servers = self.servers[1:] + self.servers[:1]

        print >>sys.stderr, 'all backends read failed', keys
        raise ReadFailedError(keys, self.servers)

    def set(self, key, value):
        if value is None:
            return
        for i, s in enumerate(self._get_servers(key)):
            if s.set(key, value):
                if i > 0:
                    self.servers = self.servers[i:] + self.servers[:i]
                return True
        #try to check
        if self.get(key) != value:
            raise WriteFailedError(key)
        return True

    def set_multi(self, values):
        for i, s in enumerate(self._get_servers('')):
            if s.set_multi(values):
                if i > 0:
                    self.servers = self.servers[i:] + self.servers[:i]
                return True
        return False

    def delete(self, key):
        for i, s in enumerate(self._get_servers(key)):
            if s.delete(key):
                if i > 0:
                    self.servers = self.servers[i:] + self.servers[:i]
                return True
        return False

    def delete_multi(self, keys):
        for i, s in enumerate(self._get_servers('')):
            if s.delete_multi(keys):
                if i > 0:
                    self.servers = self.servers[i:] + self.servers[:i]
                return True

    def incr(self, key, value):
        if value is None:
            return
        for i, s in enumerate(self._get_servers(key)):
            v = s.incr(key, value)
            if v:
                if i > 0:
                    self.servers = self.servers[i:] + self.servers[:i]
                return v

_empty_slot = '__empty_slot__##'

class CacheWrapper(object):
    """a cached wrapper of BeansDBProxy"""
    def __init__(self, db, mc):
        self.db = db
        self.mc = mc

    def get(self, key, default=None):
        r = self.mc.get(key)
        if r == _empty_slot:
            return default
        if r is None:
            r = self.db.get(key, default)
            if r is None:
                self.mc.set(key, _empty_slot, 3600)
            else:
                self.mc.set(key, r)
        return r

    def exists(self, key):
        r = self.mc.get(key)
        if r == _empty_slot:
            return False
        if self.mc.get(key) is not None:
            return True
        else :
            return self.db.exists(key)

    def get_multi(self, keys, default=None):
        rs = self.mc.get_multi(keys)
        keys = [k for k in keys if rs.get(k) is None]
        for k, v in rs.items():
            if v == _empty_slot:
                rs[k] = default
        
        if keys:
            nrs = self.db.get_multi(keys, default)
            rs.update(nrs)
           
            if default is None:
                exists = dict((k, v) for k, v in nrs.iteritems() if v is not None)
                self.mc.set_multi(exists)
                not_exists = dict((k, _empty_slot) for k, v in nrs.iteritems()
                        if v is None)
                self.mc.set_multi(not_exists, 3600)
            else:
                self.mc.set_multi(nrs)

        return rs

    def set(self, key, value):
        if value is None:
            self.mc.set(key, _empty_slot)
            self.db.delete(key)
            return True

        if self.db.set(key, value):
            return self.mc.set(key, value)
        else:
            return self.mc.delete(key)

    def set_multi(self, values):
        if self.db.set_multi(values):
            self.mc.delete_multi(values.keys())
            return True

    def delete(self, key):
        r1 = self.db.delete(key)
        r2 = self.mc.delete(key)
        return r1 and r2

    def delete_multi(self, keys):
        if self.db.delete_multi(keys):
            self.mc.delete_multi(keys)
            return True

    def incr(self, key, value):
        if value is None:
            return
        v = self.db.incr(key, value)
        self.mc.delete(key)
        return v

    def clear_thread_ident(self):
        self.mc.clear_thread_ident()


def beansdb_from_config(config, mc=None, offline=False, **kwargs):
    if isinstance(config, basestring):
        config = read_config(config, 'beansdb')

    if 'offline' in config:
        offline = config['offline']

    # TODO to be compatible
    if isinstance(config, list):
        nodes = config
    else:
        if offline:
            nodes = config.get('servers')
        else:
            nodes = config.get('proxies')

    if offline:
        db = BeansdbClient(nodes, **kwargs)
    else:
        db = BeansDBProxy(nodes, **kwargs)

    if mc:
        db = CacheWrapper(db, mc)
    return db
