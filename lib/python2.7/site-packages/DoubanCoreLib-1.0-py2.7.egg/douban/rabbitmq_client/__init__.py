#!/usr/bin/env python
#coding:utf-8
"""
"""
import random
import socket
from socket import error as socketerror
import sys
import time
from warnings import warn
import os
import pwd
from douban.utils.config import read_config

try:
    import amqplib.client_0_8 as amqp
    from amqplib.client_0_8 import AMQPException
except:
    warn('[rabbitmq]please install the rabbitmq client', RuntimeWarning)
    amqp = AMQPException = None


def retry(func):
    def _(self, *args, **kwargs):
        try:
            try:
                if self._conn is None:
                    self._connect()
                retval = func(self, *args, **kwargs)
            except (AMQPException, socketerror):
                time.sleep(0.2)
                print >> sys.stderr, "[rabbitmq]connecting to rabbitmq server %s failed, reconnecting..." % (str(self), )
                self._connect()
                retval = func(self, *args, **kwargs)
            return retval
        except (AMQPException, socketerror):
            import traceback
            self._conn = None
            print >> sys.stderr, "[rabbitmq]retry connecting failed!"
            traceback.print_exc()
            if self.log:
                self.log.write("Failed messages:" + str(args) + '\n')
                self.log.flush()
    return _

class RabbitMQ(object):
    """
        rmq=RabbitMQ()
        rmq.send("exchange_name", "message", **properties)
    """
    def __init__(self, servers, host=None, virtual_host="douban", trace=False, *args, **kwds):
        self.servers = servers
        self.virtual_host = virtual_host
        self._args = args
        self._kwds = kwds
        self.trace = trace
        self._conn = None
        self.random_server = False
        self.log = None
        if host is None:
            kwds['host'] = random.choice(self.servers)
            self.random_server = True
        else:
            kwds['host'] = host

        self._exchange_pool = {}

    def __str__(self):
        return "%s" % (self._kwds['host'])

    def open_log(self):
        euser = pwd.getpwuid(os.geteuid())[0]
        log_name = '/var/tmp/rabbitmq-%s.log' % euser
        try:
            self.log = open(log_name, "a")
        except Exception, e:
            print >> sys.stderr, "[rabbitmq]log file(%s) open error!" % \
                    log_name
            print >> sys.stderr, str(e)

    def _connect(self):
        try:
            self.__connect()
        except:
            if self.random_server:
                self._rechoose_server()
            self.__connect()
        self.open_log()

    def __connect(self):
        self._exchange_pool = {}
        self._conn = amqp.Connection(virtual_host=self.virtual_host, *self._args, **self._kwds)
        self._conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

    def _rechoose_server(self):
        # rechoice in remaining servers
        print >> sys.stderr, "[rabbitmq]server %s is down, re-choose a server" % (str(self))
        servers = list(self.servers)
        servers.remove(self._kwds['host'])
        if len(servers) == 0:
            return None
        self._kwds['host'] = random.choice(servers)

    @retry
    def send(self, exchange, message, **properties):
        if self.trace and self.log:
            self.log.write(exchange + '@@@' + message + '\n')
            self.log.flush()

        _exchange_channel = self._exchange_pool.get(exchange)

        if not _exchange_channel:
            channel = self._conn.channel()
            channel.access_request("/data", active=True, write=True, passive=True)
            channel.exchange_declare(exchange, 'fanout', passive=True)
            _exchange_channel = self._exchange_pool[exchange] = channel

        return _exchange_channel.basic_publish(
            amqp.Message(message, **properties),
            exchange#, mandatory=False, immediate=False
        )

    @retry
    def bind(self, exchange, qname, type='fanout'):
        ch = self._conn.channel()
        ch.access_request('/data', active=True, read=True)

        ch.exchange_declare(exchange, type, auto_delete=False, durable=True)
        qname, _, _ = ch.queue_declare(queue=qname, durable=True, auto_delete=False)
        ch.queue_bind(qname, exchange)
        return ch

    @retry
    def get_channel(self):
        ch = self._conn.channel()
        ch.access_request('/data', active=True, read=True)
        return ch

    def close(self, exchange):
        _exchange_channel = self._exchange_pool.get(exchange)
        if _exchange_channel:
            del self._exchange_pool[exchange]
            _exchange_channel.close()

    @retry
    def consume(self, qname, func):
        ch = self._conn.channel()

        def callback(msg):
            try:
                func(msg)
                msg.channel.basic_ack(msg.delivery_tag)
            except Exception, e:
                print e

        try:
            ch.basic_consume(qname, callback=callback)
            while ch.callbacks:
                ch.wait()

            ch.close()
        except amqp.AMQPConnectionException:
            self._conn = None
            self.b_consume(qname, func)


    @retry
    def b_consume(self, qname, func):
        ch = self._conn.channel()
        while 1:
            msg = ch.basic_get(qname)
            if msg and msg.body:
                func(msg)
                ch.basic_ack(msg.delivery_tag)
            else:
                time.sleep(1)

    #def __getattr__(self, name):
    #    return lambda message:self._send(name, message)

class FakeRabbitMQ:
    def __init__(self, *args, **kwargs):
        pass

    def bind(self, *args, **kwargs):
        pass

    def send(self, *args, **kwargs):
        pass

    def consume(self, *args, **kwargs):
        pass

if 'AMQPException' not in globals():
    RabbitMQ = FakeRabbitMQ
    amqp = None
    AMQPException = Exception

def connect(servers):
    if servers:
        return RabbitMQ(servers, userid="douban", password="douban@rabbitmq",
                connect_timeout=0.5)
    else:
        return FakeRabbitMQ()
    
def rabbitmq_from_config(config):
    if isinstance(config, basestring):
        config = read_config(config, 'rabbitmq')
    return connect(config['servers'])
    
        
