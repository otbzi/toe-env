#!/usr/bin/env python
"""beanstalkc - A beanstalkd Client Library for Python"""

__license__ = '''
Copyright (C) 2008 Andreas Bolka

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

__version__ = '0.1.1'

import sys
import time
import socket
import random

import yaml
try:
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader


def load_yaml(s):
    return yaml.load(s, Loader)

DEFAULT_HOST = 'localhost'
DEFAULT_PORT = 11300
DEFAULT_PRIORITY = 2 ** 10
DEFAULT_TTR = 120


class BeanstalkcException(Exception):
    pass


class UnexpectedResponse(BeanstalkcException):
    pass


class CommandFailed(BeanstalkcException):
    pass


class DeadlineSoon(BeanstalkcException):
    pass


class Connection(object):
    def __init__(self, host=DEFAULT_HOST, port=DEFAULT_PORT, parse_yaml=True, timeout=2):
        if parse_yaml is True:
            self.yaml_load = load_yaml
        elif parse_yaml:
            self.yaml_load = parse_yaml
        else:
            self.yaml_load = lambda x: x
        self.host = host
        self.port = port
        self.used = 'default'
        self.watched = ['default']
        self.fanout = {}
        self.connected = False
        self.timeout = timeout
        self.next_try = None
        self.fail_count = 0
        self.last_access = 0

    def __str__(self):
        return '%s:%d' % (self.host, self.port)

    def __repr__(self):
        return '<Connection(%s:%d)>' % (self.host, self.port)

    def connect(self):
        if self.fail_count > 0 and time.time() < self.next_try:
            raise socket.error("mark as dead until " + str(self.next_try))

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.settimeout(self.timeout)
        try:
            self.socket.connect((self.host, self.port))
        except socket.error, e:
            self.next_try = time.time() + 1.5 ** self.fail_count
            self.fail_count += 1
            raise e
        else:
            self.connected = True
            if self.used != 'default':
                self._use(self.used)
            for t in self.watched:
                if t != 'default':
                    self._watch(t)
            if 'default' not in self.watched:
                self.ignore('default')
            for t in self.fanout:
                self.bind(self.fanout[t], t)

    def close(self):
        self.connected = False
        self.next_try = time.time() + 1.5 ** self.fail_count
        self.fail_count += 1
        self.socket.close()

    def interact(self, command, expected_ok, expected_err=[]):
        if not self.connected:
            self.connect()

        try:
            self.socket.sendall(command)
            status, results = self.read_response()
        except socket.error:
            self.close()
            raise
        else:
            self.fail_count = 0

        if status in expected_ok:
            return results
        elif status in expected_err:
            raise CommandFailed(command.split()[0], status, results)
        else:
            self.close()
            raise UnexpectedResponse(command.split()[0], status, results)

    def read_response(self):
        data = self.socket.recv(4096)
        if not data or '\r\n' not in data:
            raise socket.error("unexpected EOF")
        i = data.index('\r\n')
        self.body = data[i + 2:]
        response = data[:i].split()
        return response[0], response[1:]

    def read_body(self, size):
        try:
            body = self.body
            while len(body) < size + 2:  # trailing crlf
                body += self.socket.recv(size + 2 - len(body))
            return body[:size]
        except socket.error:
            self.close()
            raise

    def interact_value(self, command, expected_ok, expected_err=[]):
        return self.interact(command, expected_ok, expected_err)[0]

    def interact_job(self, command, expected_ok, expected_err, reserved=True):
        jid, size = self.interact(command, expected_ok, expected_err)
        body = self.read_body(int(size))
        return Job(self, int(jid), body, reserved)

    def interact_yaml(self, command, expected_ok, expected_err=[]):
        size, = self.interact(command, expected_ok, expected_err)
        body = self.read_body(int(size))
        return self.yaml_load(body)

    def interact_peek(self, command):
        try:
            return self.interact_job(command, ['FOUND'], ['NOT_FOUND'], False)
        except CommandFailed, (_, status, results):
            return None

    # -- public interface --

    def put(self, body, priority=DEFAULT_PRIORITY, delay=0, ttr=DEFAULT_TTR):
        assert isinstance(body, str), 'Job body must be a str instance'
        jid = self.interact_value(
            'put %d %d %d %d\r\n%s\r\n' %
            (priority, delay, ttr, len(body), body),
            ['INSERTED', 'BURIED'],
            ['BAD_FORMAT', 'DRAINING', 'NOT_FOUND', 'JOB_TOO_BIG'])
        return int(jid)

    def reserve(self, timeout=None):
        if timeout is not None:
            command = 'reserve-with-timeout %d\r\n' % timeout
        else:
            command = 'reserve\r\n'
        try:
            r = self.interact_job(command,
                                  ['RESERVED'],
                                  ['DEADLINE_SOON', 'TIMED_OUT'])
            return r
        except CommandFailed, (_, status, results):
            if status == 'TIMED_OUT':
                return None
            elif status == 'DEADLINE_SOON':
                raise DeadlineSoon(results)

    def kick(self, bound=1):
        return int(self.interact_value('kick %d\r\n' % bound, ['KICKED']))

    def peek(self, jid):
        return self.interact_peek('peek %d\r\n' % jid)

    def peek_ready(self):
        return self.interact_peek('peek-ready\r\n')

    def peek_delayed(self):
        return self.interact_peek('peek-delayed\r\n')

    def peek_buried(self):
        return self.interact_peek('peek-buried\r\n')

    def tubes(self):
        return self.interact_yaml('list-tubes\r\n', ['OK'])

    def using(self):
        return self.interact_value('list-tube-used\r\n', ['USING'])

    def bindings(self):
        return self.interact_yaml('list-bindings\r\n', ['OK'])

    def use(self, name):
        if name == self.used:
            return
        try:
            self.used = name
            self.last_access = time.time()
            return self._use(name)
        except socket.error:
            pass  # keep quiet, because of it will try to use after re-connect

    def _use(self, name):
        return self.interact_value('use %s\r\n' % name, ['USING'])

    def watching(self):
        return self.interact_yaml('list-tubes-watched\r\n', ['OK'])

    def watch(self, name):
        if name not in self.watched:
            self.watched.append(name)
            try:
                return self._watch(name)
            except socket.error:
                pass  # keep quiet, because of it will try to watch after re-connect

    def _watch(self, name):
        return int(self.interact_value('watch %s\r\n' % name, ['WATCHING']))

    def ignore(self, name):
        if name not in self.watched:
            return
        self.watched.remove(name)
        try:
            return int(self.interact_value('ignore %s\r\n' % name,
                                           ['WATCHING'],
                                           ['NOT_IGNORED']))
        except CommandFailed:
            return 1

    def bind(self, src, target):
        self.fanout[target] = src
        try:
            return self.interact('bind %s %s\r\n' % (src, target), ['BINDED'])
        except socket.error:
            pass  # keep quiet, because of it will try to bind after re-connect

    def unbind(self, src, target):
        self.fanout.pop(target, None)
        return self.interact('unbind %s %s\r\n' % (src, target), ['UNBINDED', 'NOT_FOUND'])

    def stats(self):
        return self.interact_yaml('stats\r\n', ['OK'])

    def stats_tube(self, name):
        return self.interact_yaml('stats-tube %s\r\n' % name,
                                  ['OK'],
                                  ['NOT_FOUND'])

    # -- job interactors --

    def delete(self, jid):
        self.interact('delete %d\r\n' % jid, ['DELETED'])

    def release(self, jid, priority=None, delay=0):
        self.interact('release %d %d %d\r\n' % (jid, priority, delay),
                      ['RELEASED', 'BURIED'],
                      ['NOT_FOUND'])

    def bury(self, jid, priority):
        self.interact('bury %d %d\r\n' % (jid, priority),
                      ['BURIED'],
                      ['NOT_FOUND'])

    def touch(self, jid):
        self.interact('touch %d\r\n' % jid, ['TOUCHED'], ['NOT_FOUND'])

    def stats_job(self, jid):
        return self.interact_yaml('stats-job %d\r\n' % jid,
                                  ['OK'],
                                  ['NOT_FOUND'])

    def pause(self, name, delay):
        return self.interact('pause-tube %s %d\r\n' % (name, delay), ['PAUSED'], ['NOT_FOUND'])

#
# pool of connections
#


class Pool(object):
    def __init__(self, servers, timeout=2):
        def connect(s):
            host, port = s.split(':')
            return Connection(host, int(port), timeout=timeout)
        self.conns = [connect(s) for s in servers]
        random.shuffle(self.conns)

    def use(self, name):
        for c in self.conns:
            c.use(name)

    def put(self, body, priority=DEFAULT_PRIORITY, delay=0, ttr=DEFAULT_TTR):
        assert isinstance(body, str)
        for c in self.conns:
            try:
                return c, c.put(body, priority, delay, ttr)
            except socket.error, e:
                print >>sys.stderr, 'put failed', c, e
                self.conns = self.conns[1:] + self.conns[:1]
        if self.conns:
            raise

    def send(self, tube, body):
        "put message in a tube in one shot"
        def gen_key(conn):
            return conn.used != tube, conn.last_access
        # sort connections to reduce use(tube) called
        conns = sorted(self.conns, key=gen_key)
        for c in conns:
            try:
                c.use(tube)
                return c, c.put(body)
            except socket.error, e:
                print >>sys.stderr, 'put failed', c, e
        if conns:
            raise

    def watch(self, name):
        for c in self.conns:
            c.watch(name)

    def reserve(self, timeout=None):
        if timeout != 0:
            r = self.reserve(0)
            if r:
                return r

        if timeout > 0:
            timeout = max(timeout, 1)  # or 0.x will became 0

        while True:
            for c in self.conns:
                try:
                    r = c.reserve(timeout is None and 1 or timeout)
                    if r:
                        return r
                except socket.error, e:
                    # print >>sys.stderr, 'reserve failed', c, e
                    pass

                self.conns = self.conns[1:] + self.conns[:1]
            if timeout is not None:
                break
            time.sleep(0.1)

    def bind(self, src, target):
        for c in self.conns:
            c.bind(src, target)

    def unbind(self, src, target):
        for c in self.conns:
            c.unbind(src, target)

    def stats(self):
        stats = []
        for c in self.conns:
            try:
                stats.append(c.stats())
            except socket.error, e:
                print >>sys.stderr, 'stats fail:', c, e
        return stats

    def stats_tube(self, name):
        stats = []
        for c in self.conns:
            try:
                stats.append(c.stats_tube(name))
            except socket.error, e:
                print >>sys.stderr, 'stats_tube fail:', c, name, e
        return stats


class Job(object):
    def __init__(self, conn, jid, body, reserved=True):
        self.conn = conn
        self.jid = jid
        self.body = body
        self.reserved = reserved
        self.stat = {}

    # -- public interface --

    def delete(self):
        self.conn.delete(self.jid)
        self.reserved = False

    def release(self, priority=None, delay=0):
        if self.reserved:
            self.conn.release(self.jid, priority or self.stats()['pri'], delay)
            self.reserved = False

    def bury(self, priority=None):
        if self.reserved:
            self.conn.bury(self.jid, priority or self.stats()['pri'])
            self.reserved = False

    def touch(self):
        if self.reserved:
            self.conn.touch(self.jid)

    def stats(self):
        if not self.stat:
            self.stat = self.conn.stats_job(self.jid)
        return self.stat


if __name__ == '__main__':
    import doctest
    import os
    import signal
    try:
        pid = os.spawnlp(os.P_NOWAIT,
                         'beanstalkd',
                         'beanstalkd', '-l', '127.0.0.1', '-p', '14711')
        doctest.testfile('TUTORIAL', optionflags=doctest.ELLIPSIS)
    finally:
        os.kill(pid, signal.SIGTERM)
